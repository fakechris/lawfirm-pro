import { PrismaClient } from '@prisma/client';
import { spawn } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

export interface VulnerabilityScan {
  id: string;
  type: 'AUTOMATED' | 'MANUAL' | 'HYBRID';
  scanner: string;
  target: string;
  startTime: Date;
  endTime?: Date;
  status: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
  vulnerabilities: Vulnerability[];
  summary: ScanSummary;
  configuration: ScanConfiguration;
}

export interface Vulnerability {
  id: string;
  cveId?: string;
  title: string;
  description: string;
  severity: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssScore?: number;
  affectedComponent: string;
  evidence?: string;
  remediation: Remediation;
  discoveredAt: Date;
  status: 'OPEN' | 'IN_PROGRESS' | 'RESOLVED' | 'FALSE_POSITIVE';
  assignedTo?: string;
  dueDate?: Date;
}

export interface Remediation {
  type: 'PATCH' | 'CONFIGURATION' | 'CODE_CHANGE' | 'WORKAROUND';
  description: string;
  steps: string[];
  estimatedEffort: 'LOW' | 'MEDIUM' | 'HIGH';
  priority: 'IMMEDIATE' | 'HIGH' | 'MEDIUM' | 'LOW';
}

export interface ScanSummary {
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  infoCount: number;
  riskScore: number;
  scanDuration: number;
}

export interface ScanConfiguration {
  enabledScanners: string[];
  excludedPaths: string[];
  maxScanDuration: number;
  parallelScans: number;
  alertThreshold: number;
  autoRemediation: boolean;
}

export interface PenetrationTest {
  id: string;
  type: 'BLACK_BOX' | 'WHITE_BOX' | 'GRAY_BOX';
  scope: TestScope;
  methodology: TestMethodology;
  findings: PenetrationFinding[];
  report: TestReport;
  scheduledDate: Date;
  duration: number;
  testers: string[];
  status: 'PLANNED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';
}

export interface TestScope {
  targets: string[];
  excludedTargets: string[];
  testTypes: string[];
  timeConstraints: {
    startTime: Date;
    endTime: Date;
    businessHoursOnly: boolean;
  };
}

export interface TestMethodology {
  phases: TestPhase[];
  tools: string[];
  rulesOfEngagement: string[];
  reporting: ReportingRequirements;
}

export interface TestPhase {
  name: string;
  description: string;
  objectives: string[];
  techniques: string[];
  tools: string[];
  estimatedDuration: number;
}

export interface PenetrationFinding {
  id: string;
  title: string;
  description: string;
  risk: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  impact: string;
  likelihood: 'LOW' | 'MEDIUM' | 'HIGH';
  evidence: string[];
  affectedAssets: string[];
  remediation: Remediation;
  discoveredAt: Date;
  status: 'OPEN' | 'VERIFIED' | 'REMEDIATED' | 'ACCEPTED';
}

export interface TestReport {
  executiveSummary: string;
  technicalDetails: string;
  methodology: string;
  findings: PenetrationFinding[];
  riskAssessment: string;
  recommendations: string[];
  appendices: string[];
}

export class VulnerabilityAssessmentService {
  private prisma: PrismaClient;
  private config: ScanConfiguration;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.config = {
      enabledScanners: ['owasp-zap', 'nikto', 'nmap', 'snyk', 'semgrep'],
      excludedPaths: ['/tmp', '/dev', '/proc'],
      maxScanDuration: 3600000, // 1 hour
      parallelScans: 3,
      alertThreshold: 80,
      autoRemediation: false
    };
  }

  async performVulnerabilityScan(target: string, options?: Partial<ScanConfiguration>): Promise<VulnerabilityScan> {
    const scanId = `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = new Date();
    
    const scan: VulnerabilityScan = {
      id: scanId,
      type: 'AUTOMATED',
      scanner: 'multi-scanner',
      target,
      startTime,
      status: 'RUNNING',
      vulnerabilities: [],
      summary: {
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        infoCount: 0,
        riskScore: 0,
        scanDuration: 0
      },
      configuration: { ...this.config, ...options }
    };

    try {
      // Store scan in database
      await this.prisma.vulnerabilityScan.create({
        data: {
          id: scan.id,
          type: scan.type,
          scanner: scan.scanner,
          target: scan.target,
          startTime: scan.startTime,
          status: scan.status,
          configuration: scan.configuration as any
        }
      });

      // Execute parallel scans
      const scanResults = await this.executeParallelScans(target, scan.configuration);
      
      // Process results
      scan.vulnerabilities = scanResults.flat();
      scan.summary = this.calculateScanSummary(scan.vulnerabilities);
      scan.endTime = new Date();
      scan.status = 'COMPLETED';

      // Store vulnerabilities
      for (const vuln of scan.vulnerabilities) {
        await this.prisma.vulnerability.create({
          data: {
            id: vuln.id,
            cveId: vuln.cveId,
            title: vuln.title,
            description: vuln.description,
            severity: vuln.severity,
            cvssScore: vuln.cvssScore,
            affectedComponent: vuln.affectedComponent,
            evidence: vuln.evidence,
            remediation: vuln.remediation as any,
            discoveredAt: vuln.discoveredAt,
            status: vuln.status,
            scanId: scan.id
          }
        });
      }

      // Update scan in database
      await this.prisma.vulnerabilityScan.update({
        where: { id: scan.id },
        data: {
          endTime: scan.endTime,
          status: scan.status,
          summary: scan.summary as any
        }
      });

      // Send alerts if threshold exceeded
      if (scan.summary.riskScore > scan.configuration.alertThreshold) {
        await this.sendVulnerabilityAlert(scan);
      }

      // Auto-remediation if enabled
      if (scan.configuration.autoRemediation) {
        await this.performAutoRemediation(scan);
      }

      console.log(`Vulnerability scan completed for ${target}. Found ${scan.summary.totalVulnerabilities} vulnerabilities.`);
      return scan;

    } catch (error) {
      console.error(`Vulnerability scan failed for ${target}:`, error);
      scan.status = 'FAILED';
      scan.endTime = new Date();
      
      // Update scan status
      await this.prisma.vulnerabilityScan.update({
        where: { id: scan.id },
        data: {
          endTime: scan.endTime,
          status: scan.status
        }
      });
      
      throw error;
    }
  }

  private async executeParallelScans(target: string, config: ScanConfiguration): Promise<Vulnerability[][]> {
    const promises: Promise<Vulnerability[]>[] = [];
    
    for (const scanner of config.enabledScanners) {
      if (promises.length >= config.parallelScans) {
        break;
      }
      
      switch (scanner) {
        case 'owasp-zap':
          promises.push(this.runOWASPZAPScan(target));
          break;
        case 'nikto':
          promises.push(this.runNiktoScan(target));
          break;
        case 'nmap':
          promises.push(this.runNmapScan(target));
          break;
        case 'snyk':
          promises.push(this.runSnykScan(target));
          break;
        case 'semgrep':
          promises.push(this.runSemgrepScan(target));
          break;
      }
    }

    return Promise.allSettled(promises)
      .then(results => results.map(result => 
        result.status === 'fulfilled' ? result.value : []
      ));
  }

  private async runOWASPZAPScan(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      console.log(`Starting OWASP ZAP scan for ${target}`);
      
      // Simulate OWASP ZAP scan
      await this.delay(5000); // Simulate scan time
      
      // Mock vulnerabilities for demonstration
      const mockVulnerabilities = [
        {
          id: `zap_${Date.now()}_1`,
          title: 'Cross-Site Scripting (XSS)',
          description: 'Reflected XSS vulnerability found in search functionality',
          severity: 'HIGH' as const,
          cvssScore: 7.5,
          affectedComponent: `${target}/search`,
          evidence: 'Parameter "q" vulnerable to XSS',
          remediation: {
            type: 'CODE_CHANGE' as const,
            description: 'Implement input validation and output encoding',
            steps: [
              'Validate all user input',
              'Encode output for HTML context',
              'Implement Content Security Policy'
            ],
            estimatedEffort: 'MEDIUM' as const,
            priority: 'HIGH' as const
          },
          discoveredAt: new Date(),
          status: 'OPEN' as const
        },
        {
          id: `zap_${Date.now()}_2`,
          title: 'Missing Security Headers',
          description: 'Security headers not properly configured',
          severity: 'MEDIUM' as const,
          cvssScore: 5.4,
          affectedComponent: target,
          evidence: 'Missing X-Content-Type-Options, X-Frame-Options',
          remediation: {
            type: 'CONFIGURATION' as const,
            description: 'Configure security headers in web server',
            steps: [
              'Add X-Content-Type-Options: nosniff',
              'Add X-Frame-Options: DENY',
              'Add Content-Security-Policy header'
            ],
            estimatedEffort: 'LOW' as const,
            priority: 'MEDIUM' as const
          },
          discoveredAt: new Date(),
          status: 'OPEN' as const
        }
      ];
      
      vulnerabilities.push(...mockVulnerabilities);
      console.log(`OWASP ZAP scan completed for ${target}. Found ${vulnerabilities.length} vulnerabilities.`);
      
    } catch (error) {
      console.error(`OWASP ZAP scan failed for ${target}:`, error);
    }
    
    return vulnerabilities;
  }

  private async runNiktoScan(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      console.log(`Starting Nikto scan for ${target}`);
      
      // Simulate Nikto scan
      await this.delay(8000); // Simulate scan time
      
      // Mock vulnerabilities for demonstration
      const mockVulnerabilities = [
        {
          id: `nikto_${Date.now()}_1`,
          title: 'Server Information Disclosure',
          description: 'Server version information leaked in response headers',
          severity: 'LOW' as const,
          cvssScore: 3.5,
          affectedComponent: target,
          evidence: 'Server header reveals version information',
          remediation: {
            type: 'CONFIGURATION' as const,
            description: 'Configure server to not disclose version information',
            steps: [
              'Modify server configuration',
              'Remove or obscure Server header',
              'Test configuration changes'
            ],
            estimatedEffort: 'LOW' as const,
            priority: 'LOW' as const
          },
          discoveredAt: new Date(),
          status: 'OPEN' as const
        }
      ];
      
      vulnerabilities.push(...mockVulnerabilities);
      console.log(`Nikto scan completed for ${target}. Found ${vulnerabilities.length} vulnerabilities.`);
      
    } catch (error) {
      console.error(`Nikto scan failed for ${target}:`, error);
    }
    
    return vulnerabilities;
  }

  private async runNmapScan(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      console.log(`Starting Nmap scan for ${target}`);
      
      // Simulate Nmap scan
      await this.delay(3000); // Simulate scan time
      
      // Mock vulnerabilities for demonstration
      const mockVulnerabilities = [
        {
          id: `nmap_${Date.now()}_1`,
          title: 'Open SSH Port',
          description: 'SSH service accessible from external network',
          severity: 'INFO' as const,
          affectedComponent: `${target}:22`,
          evidence: 'SSH port 22 is open',
          remediation: {
            type: 'CONFIGURATION' as const,
            description: 'Consider restricting SSH access to internal network only',
            steps: [
              'Configure firewall rules',
              'Implement IP whitelisting',
              'Consider VPN-only access'
            ],
            estimatedEffort: 'LOW' as const,
            priority: 'LOW' as const
          },
          discoveredAt: new Date(),
          status: 'OPEN' as const
        }
      ];
      
      vulnerabilities.push(...mockVulnerabilities);
      console.log(`Nmap scan completed for ${target}. Found ${vulnerabilities.length} vulnerabilities.`);
      
    } catch (error) {
      console.error(`Nmap scan failed for ${target}:`, error);
    }
    
    return vulnerabilities;
  }

  private async runSnykScan(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      console.log(`Starting Snyk scan for ${target}`);
      
      // Simulate Snyk scan
      await this.delay(10000); // Simulate scan time
      
      // Mock vulnerabilities for demonstration
      const mockVulnerabilities = [
        {
          id: `snyk_${Date.now()}_1`,
          cveId: 'CVE-2023-1234',
          title: 'Remote Code Execution in npm package',
          description: 'Critical vulnerability in express package allows RCE',
          severity: 'CRITICAL' as const,
          cvssScore: 9.8,
          affectedComponent: 'node_modules/express',
          evidence: 'express@4.16.0 vulnerable to RCE',
          remediation: {
            type: 'PATCH' as const,
            description: 'Update express package to latest version',
            steps: [
              'Update package.json',
              'Run npm update',
              'Verify application functionality'
            ],
            estimatedEffort: 'LOW' as const,
            priority: 'IMMEDIATE' as const
          },
          discoveredAt: new Date(),
          status: 'OPEN' as const
        }
      ];
      
      vulnerabilities.push(...mockVulnerabilities);
      console.log(`Snyk scan completed for ${target}. Found ${vulnerabilities.length} vulnerabilities.`);
      
    } catch (error) {
      console.error(`Snyk scan failed for ${target}:`, error);
    }
    
    return vulnerabilities;
  }

  private async runSemgrepScan(target: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      console.log(`Starting Semgrep scan for ${target}`);
      
      // Simulate Semgrep scan
      await this.delay(7000); // Simulate scan time
      
      // Mock vulnerabilities for demonstration
      const mockVulnerabilities = [
        {
          id: `semgrep_${Date.now()}_1`,
          title: 'SQL Injection Vulnerability',
          description: 'Potential SQL injection in user authentication',
          severity: 'HIGH' as const,
          cvssScore: 8.1,
          affectedComponent: 'src/auth/auth.service.ts',
          evidence: 'User input concatenated directly into SQL query',
          remediation: {
            type: 'CODE_CHANGE' as const,
            description: 'Use parameterized queries instead of string concatenation',
            steps: [
              'Replace string concatenation with parameterized queries',
              'Implement input validation',
              'Add SQL injection tests'
            ],
            estimatedEffort: 'MEDIUM' as const,
            priority: 'HIGH' as const
          },
          discoveredAt: new Date(),
          status: 'OPEN' as const
        }
      ];
      
      vulnerabilities.push(...mockVulnerabilities);
      console.log(`Semgrep scan completed for ${target}. Found ${vulnerabilities.length} vulnerabilities.`);
      
    } catch (error) {
      console.error(`Semgrep scan failed for ${target}:`, error);
    }
    
    return vulnerabilities;
  }

  private calculateScanSummary(vulnerabilities: Vulnerability[]): ScanSummary {
    const summary = {
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
      infoCount: 0,
      riskScore: 0,
      scanDuration: 0
    };

    // Count vulnerabilities by severity
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'CRITICAL':
          summary.criticalCount++;
          break;
        case 'HIGH':
          summary.highCount++;
          break;
        case 'MEDIUM':
          summary.mediumCount++;
          break;
        case 'LOW':
          summary.lowCount++;
          break;
        case 'INFO':
          summary.infoCount++;
          break;
      }
    });

    // Calculate risk score (weighted)
    summary.riskScore = Math.round(
      (summary.criticalCount * 10) +
      (summary.highCount * 7) +
      (summary.mediumCount * 4) +
      (summary.lowCount * 1)
    );

    return summary;
  }

  private async sendVulnerabilityAlert(scan: VulnerabilityScan): Promise<void> {
    const alert = {
      type: 'VULNERABILITY_SCAN_HIGH_RISK',
      scanId: scan.id,
      target: scan.target,
      riskScore: scan.summary.riskScore,
      criticalCount: scan.summary.criticalCount,
      highCount: scan.summary.highCount,
      timestamp: new Date().toISOString()
    };

    console.log('High-risk vulnerability alert:', alert);
    
    // In a real implementation, this would send alerts to various channels
    // Email, Slack, PagerDuty, etc.
  }

  private async performAutoRemediation(scan: VulnerabilityScan): Promise<void> {
    const remediableVulns = scan.vulnerabilities.filter(vuln => 
      vuln.remediation.type === 'PATCH' && 
      vuln.severity === 'CRITICAL'
    );

    for (const vuln of remediableVulns) {
      try {
        console.log(`Attempting auto-remediation for vulnerability: ${vuln.title}`);
        
        // Simulate auto-remediation
        await this.delay(2000);
        
        // Update vulnerability status
        await this.prisma.vulnerability.update({
          where: { id: vuln.id },
          data: { status: 'IN_PROGRESS' }
        });
        
        console.log(`Auto-remediation initiated for vulnerability: ${vuln.id}`);
        
      } catch (error) {
        console.error(`Auto-remediation failed for vulnerability ${vuln.id}:`, error);
      }
    }
  }

  async schedulePenetrationTest(
    type: 'BLACK_BOX' | 'WHITE_BOX' | 'GRAY_BOX',
    scope: TestScope,
    scheduledDate: Date,
    duration: number,
    testers: string[]
  ): Promise<PenetrationTest> {
    const testId = `pentest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const test: PenetrationTest = {
      id: testId,
      type,
      scope,
      methodology: this.getDefaultMethodology(type),
      findings: [],
      report: {
        executiveSummary: '',
        technicalDetails: '',
        methodology: '',
        findings: [],
        riskAssessment: '',
        recommendations: [],
        appendices: []
      },
      scheduledDate,
      duration,
      testers,
      status: 'PLANNED'
    };

    // Store test in database
    await this.prisma.penetrationTest.create({
      data: {
        id: test.id,
        type: test.type,
        scope: test.scope as any,
        methodology: test.methodology as any,
        scheduledDate: test.scheduledDate,
        duration: test.duration,
        testers: test.testers,
        status: test.status
      }
    });

    console.log(`Penetration test scheduled: ${testId}`);
    return test;
  }

  private getDefaultMethodology(type: string): TestMethodology {
    const phases: TestPhase[] = [
      {
        name: 'Reconnaissance',
        description: 'Information gathering and target identification',
        objectives: ['Identify attack surface', 'Map network infrastructure', 'Discover technologies'],
        techniques: ['OSINT', 'Port scanning', 'Service enumeration'],
        tools: ['nmap', 'whois', 'sublist3r'],
        estimatedDuration: 3600
      },
      {
        name: 'Scanning',
        description: 'Vulnerability scanning and analysis',
        objectives: ['Identify vulnerabilities', 'Assess attack vectors', 'Map entry points'],
        techniques: ['Vulnerability scanning', 'Service analysis', 'Configuration review'],
        tools: ['nessus', 'openvas', 'nikto'],
        estimatedDuration: 7200
      },
      {
        name: 'Exploitation',
        description: 'Attempt to exploit identified vulnerabilities',
        objectives: ['Gain access', 'Escalate privileges', 'Maintain access'],
        techniques: ['Exploit execution', 'Privilege escalation', 'Persistence'],
        tools: ['metasploit', 'custom exploits', 'social engineering'],
        estimatedDuration: 5400
      },
      {
        name: 'Post-Exploitation',
        description: 'Assess impact and document findings',
        objectives: ['Document findings', 'Assess business impact', 'Provide remediation'],
        techniques: ['Evidence collection', 'Impact analysis', 'Report generation'],
        tools: ['evidence collection tools', 'reporting tools'],
        estimatedDuration: 3600
      }
    ];

    return {
      phases,
      tools: ['nmap', 'metasploit', 'nessus', 'burp-suite', 'sqlmap'],
      rulesOfEngagement: [
        'No denial of service attacks',
        'No data destruction',
        'Respect privacy and confidentiality',
        'Report findings immediately',
        'Stop if critical systems affected'
      ],
      reporting: {
        executiveSummaryRequired: true,
        technicalDetailsRequired: true,
        remediationRequired: true,
        evidenceRequired: true,
        format: 'PDF'
      }
    };
  }

  async getVulnerabilityTrends(days: number = 30): Promise<{
    totalVulnerabilities: number;
    resolvedVulnerabilities: number;
    criticalTrend: number;
    riskTrend: number;
    topVulnerabilityTypes: string[];
  }> {
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    
    const [totalVulns, resolvedVulns, criticalVulns] = await Promise.all([
      this.prisma.vulnerability.count({
        where: { discoveredAt: { gte: startDate } }
      }),
      this.prisma.vulnerability.count({
        where: { 
          discoveredAt: { gte: startDate },
          status: 'RESOLVED'
        }
      }),
      this.prisma.vulnerability.count({
        where: { 
          discoveredAt: { gte: startDate },
          severity: 'CRITICAL'
        }
      })
    ]);

    const previousPeriodStart = new Date(startDate.getTime() - days * 24 * 60 * 60 * 1000);
    const [previousCriticalVulns] = await Promise.all([
      this.prisma.vulnerability.count({
        where: { 
          discoveredAt: { 
            gte: previousPeriodStart,
            lt: startDate
          },
          severity: 'CRITICAL'
        }
      })
    ]);

    const criticalTrend = previousCriticalVulns > 0 
      ? ((criticalVulns - previousCriticalVulns) / previousCriticalVulns) * 100
      : 0;

    const riskTrend = this.calculateRiskTrend(startDate);

    return {
      totalVulnerabilities: totalVulns,
      resolvedVulnerabilities: resolvedVulns,
      criticalTrend,
      riskTrend,
      topVulnerabilityTypes: await this.getTopVulnerabilityTypes(startDate)
    };
  }

  private async calculateRiskTrend(startDate: Date): Promise<number> {
    const previousPeriodStart = new Date(startDate.getTime() - 30 * 24 * 60 * 60 * 1000);
    
    const [currentRisk, previousRisk] = await Promise.all([
      this.calculateRiskScore(startDate, new Date()),
      this.calculateRiskScore(previousPeriodStart, startDate)
    ]);

    return previousRisk > 0 ? ((currentRisk - previousRisk) / previousRisk) * 100 : 0;
  }

  private async calculateRiskScore(startDate: Date, endDate: Date): Promise<number> {
    const vulnerabilities = await this.prisma.vulnerability.findMany({
      where: { discoveredAt: { gte: startDate, lt: endDate } }
    });

    return vulnerabilities.reduce((score, vuln) => {
      switch (vuln.severity) {
        case 'CRITICAL': return score + 10;
        case 'HIGH': return score + 7;
        case 'MEDIUM': return score + 4;
        case 'LOW': return score + 1;
        default: return score;
      }
    }, 0);
  }

  private async getTopVulnerabilityTypes(startDate: Date): Promise<string[]> {
    const vulnerabilities = await this.prisma.vulnerability.findMany({
      where: { discoveredAt: { gte: startDate } },
      select: { title: true }
    });

    const typeCounts = vulnerabilities.reduce((acc, vuln) => {
      const type = this.extractVulnerabilityType(vuln.title);
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return Object.entries(typeCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([type]) => type);
  }

  private extractVulnerabilityType(title: string): string {
    if (title.includes('XSS') || title.includes('Cross-Site')) return 'XSS';
    if (title.includes('SQL') && title.includes('Injection')) return 'SQL Injection';
    if (title.includes('RCE') || title.includes('Remote Code')) return 'RCE';
    if (title.includes('CSRF') || title.includes('Cross-Site Request')) return 'CSRF';
    return 'Other';
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export const vulnerabilityAssessmentService = new VulnerabilityAssessmentService(new PrismaClient());